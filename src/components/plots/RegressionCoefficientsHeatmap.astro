---
export interface Props {
  name: string;
  regressionCoefficients?: any;
}

const { name, regressionCoefficients } = Astro.props;

// Use the provided regression coefficients
const coefficients = regressionCoefficients || {};
---

<div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
  <h3 class="text-lg font-semibold text-gray-900 mb-4">Regression Coefficients</h3>
  
  <div class="overflow-x-auto">
    <div id={`heatmap-${name}`} class="min-w-full">
      <!-- Heatmap will be rendered here -->
    </div>
  </div>
  
  <!-- Legend -->
  <div class="mt-4 flex items-center justify-center space-x-4">
    <div class="flex items-center space-x-2">
      <div class="w-4 h-4 bg-blue-800"></div>
      <span class="text-xs text-gray-600">-1.0</span>
    </div>
    <div class="flex items-center space-x-2">
      <div class="w-4 h-4 bg-white border border-gray-300"></div>
      <span class="text-xs text-gray-600">0.0</span>
    </div>
    <div class="flex items-center space-x-2">
      <div class="w-4 h-4 bg-red-800"></div>
      <span class="text-xs text-gray-600">1.0</span>
    </div>
  </div>
</div>

<script define:vars={{ name, coefficients }}>
  document.addEventListener('DOMContentLoaded', () => {
    renderHeatmap();
  });

  // Listen for loading completion (when content becomes visible)
  const checkLoadingComplete = () => {
    const mainContent = document.getElementById('gene-main-content');
    const loadingOverlay = document.getElementById('gene-loading-overlay');
    
    if (mainContent && loadingOverlay) {
      // Check if loading is complete (main content is visible)
      if (mainContent.style.display !== 'none' && loadingOverlay.style.display === 'none') {
        setTimeout(() => {
          renderHeatmap();
        }, 100);
        return true;
      }
    }
    return false;
  };

  // Check for loading completion periodically
  const loadingCheckInterval = setInterval(() => {
    if (checkLoadingComplete()) {
      clearInterval(loadingCheckInterval);
    }
  }, 200);

  // Also check when main content becomes visible
  const observer = new MutationObserver(() => {
    if (checkLoadingComplete()) {
      observer.disconnect();
      clearInterval(loadingCheckInterval);
    }
  });

  // Start observing the main content element
  document.addEventListener('DOMContentLoaded', () => {
    const mainContent = document.getElementById('gene-main-content');
    if (mainContent) {
      observer.observe(mainContent, { 
        attributes: true, 
        attributeFilter: ['style', 'display'] 
      });
    }
  });

  function renderHeatmap() {
    const container = document.getElementById(`heatmap-${name}`);
    if (!container) return;
    
    // Ensure container uses full width
    container.style.width = '100%';

    // Extract data for the specific transcription factor
    const conditions = Object.keys(coefficients);
    const allAssays = new Set();
    
    // Collect all unique assays
    conditions.forEach(condition => {
      Object.keys(coefficients[condition]).forEach(assay => {
        allAssays.add(assay);
      });
    });
    
    const assays = Array.from(allAssays);

    // Create the heatmap table
    let html = '<table class="w-full border-collapse table-auto">';
    
    // Header row
    html += '<thead><tr><th class="border border-gray-300 px-3 py-2 bg-gray-50 text-xs font-medium text-gray-700"></th>';
    conditions.forEach(condition => {
      html += `<th class="border border-gray-300 px-3 py-2 bg-gray-50 text-xs font-medium text-gray-700">${condition}</th>`;
    });
    html += '</tr></thead>';
    
    // Data rows
    html += '<tbody>';
    assays.forEach(assay => {
      html += '<tr>';
      html += `<td class="border border-gray-300 px-3 py-2 bg-gray-50 text-xs font-medium text-gray-700">${assay.replace('_', ' ')}</td>`;
      
      conditions.forEach(condition => {
        const value = coefficients[condition]?.[assay];
        let cellContent = '';
        let bgColor = 'bg-gray-100';
        
        if (value !== undefined && value !== null && typeof value === 'number' && !isNaN(value)) {
          // Normalize value to 0-1 range for color mapping
          const normalizedValue = (value + 1) / 2; // Convert from [-1,1] to [0,1]
          
          if (value < 0) {
            // Blue shades for negative values
            const intensity = Math.abs(value);
            const blue = Math.round(255 - (intensity * 155)); // 255 to 100
            bgColor = `background-color: rgb(${blue}, ${blue}, 255)`;
          } else if (value > 0) {
            // Red shades for positive values
            const intensity = value;
            const redGreen = Math.round(255 - (intensity * 155)); // 255 to 100
            bgColor = `background-color: rgb(255, ${redGreen}, ${redGreen})`;
          } else {
            // White for zero
            bgColor = 'background-color: white';
          }
          
          cellContent = value.toFixed(3);
        } else {
          cellContent = 'N/A';
          bgColor = 'background-color: #f3f4f6';
        }
        
        html += `<td class="border border-gray-300 px-2 py-2 text-xs text-center" style="${bgColor}">${cellContent}</td>`;
      });
      
      html += '</tr>';
    });
    html += '</tbody></table>';
    
    container.innerHTML = html;
    
    // Force table to recalculate its layout
    const table = container.querySelector('table');
    if (table) {
      table.style.width = '100%';
      table.style.tableLayout = 'auto';
    }
  }
</script>

<style>
  /* Ensure consistent cell sizing and full width usage */
  table {
    width: 100% !important;
    table-layout: auto;
  }
  
  table td, table th {
    min-width: 80px;
    text-align: center;
    width: auto;
  }
</style> 