---
import metadata from "../assets/metadata.json";
import TranscriptionFactorEntry from "./TranscriptionFactorEntry.astro";
import AssayToggleButtons from "./AssayToggleButtons.astro";

export interface Props {
  overviewData: any;
}

const { overviewData } = Astro.props;
---

<div class="max-w-4xl mx-auto px-4 py-6">
  <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Transcription Factor Rankings</h2>
  
  <!-- Assay Selector with Note -->
  <div class="mb-6">
    <p class="text-sm text-gray-600 mb-3 text-center">
      Select which chromatin accessibility assays to include in the ranking calculation. <br />
      Rankings are based on average scores across selected assays.
    </p>
    <AssayToggleButtons />
  </div>
  
  <!-- Search Field -->
  <div class="mb-4">
    <div class="relative">
      <input 
        type="text" 
        id="tf-search" 
        placeholder="Search transcription factors..." 
        class="w-full px-4 py-2 pl-10 pr-4 text-gray-700 bg-white border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
      />
      <div class="absolute inset-y-0 left-0 flex items-center pl-3">
        <svg class="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
        </svg>
      </div>
      <button 
        id="clear-search" 
        class="absolute inset-y-0 right-0 flex items-center pr-3 text-gray-400 hover:text-gray-600"
        style="display: none;"
      >
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    </div>
  </div>
  
  <div id="ranking-container" class="bg-white rounded-lg border border-gray-200 shadow-sm">
    <div class="px-6 py-4 border-b border-gray-200 bg-gray-50 rounded-t-lg">
      <div class="grid grid-cols-3 gap-4 font-semibold text-gray-700">
        <span>Rank</span>
        <span>Transcription Factor</span>
        <span class="text-right">Average Score</span>
      </div>
    </div>
    <div id="ranking-list" class="divide-y divide-gray-100" style="display: flex; flex-direction: column;">
      {(metadata as any).transcription_factors.map((tf: string, index: number) => (
        <div data-tf={tf} style={`order: ${index}`} class="tf-entry">
          <TranscriptionFactorEntry 
            rank={index + 1}
            name={tf}
            averageScore={0}
            assayCount={0}
            overviewData={overviewData}
          />
        </div>
      ))}
    </div>
  </div>
</div>

<script define:vars={{ overviewData }}>
  function calculateRankings() {
    // Get currently active assays
    const activeAssays = Array.from(document.querySelectorAll('.assay-toggle[data-active="true"]'))
      .map(button => button.getAttribute('data-assay'));
    
    if (activeAssays.length === 0) return [];
    
    // Calculate average scores for each transcription factor
    const tfScores = {};
    
    // Iterate through all transcription factors and their DCG scores
    Object.keys(overviewData).forEach(tf => {
      const dcgScores = overviewData[tf].dcg || {};
      
      // Check each active assay for this TF
      activeAssays.forEach(assay => {
        if (dcgScores[assay] !== undefined) {
          if (!tfScores[tf]) {
            tfScores[tf] = { scores: [], total: 0, count: 0 };
          }
          tfScores[tf].scores.push(dcgScores[assay]);
          tfScores[tf].total += dcgScores[assay];
          tfScores[tf].count += 1;
        }
      });
    });
    
    // Calculate averages and create ranking array
    const rankings = Object.keys(tfScores).map(tf => ({
      name: tf,
      averageScore: tfScores[tf].total / tfScores[tf].count,
      assayCount: tfScores[tf].count
    }));
    
    // Sort by average score (descending)
    rankings.sort((a, b) => b.averageScore - a.averageScore);
    
    return rankings;
  }
  
  function updateEntryContent(entryElement, rank, averageScore, assayCount) {
    // Find and update the rank
    const rankSpan = entryElement.querySelector('.text-gray-600');
    if (rankSpan) rankSpan.textContent = `#${rank}`;
    
    // Find and update the score
    const scoreSpan = entryElement.querySelector('.text-blue-600');
    if (scoreSpan) scoreSpan.textContent = averageScore.toFixed(3);
    
    // Find and update the assay count
    const assaySpan = entryElement.querySelector('.text-gray-500');
    if (assaySpan) assaySpan.textContent = `(${assayCount} assay${assayCount !== 1 ? 's' : ''})`;
  }
  
  function getSearchTerm() {
    const searchInput = document.getElementById('tf-search');
    return searchInput ? searchInput.value.toLowerCase().trim() : '';
  }

  function matchesSearch(tfName, searchTerm) {
    if (!searchTerm) return true;
    return tfName.toLowerCase().includes(searchTerm);
  }

  function updateRankingDisplay() {
    const rankings = calculateRankings();
    const searchTerm = getSearchTerm();
    const allEntries = document.querySelectorAll('.tf-entry');
    
    // Hide all entries initially
    allEntries.forEach(entry => {
      entry.style.display = 'none';
    });
    
    // Filter rankings based on search term, but preserve original ranks
    const filteredRankings = rankings
      .map((tf, originalIndex) => ({ ...tf, originalRank: originalIndex + 1 }))
      .filter(tf => matchesSearch(tf.name, searchTerm));
    
    // Update and show entries that have data and match search
    filteredRankings.forEach((tf, displayIndex) => {
      const entryElement = document.querySelector(`[data-tf="${tf.name}"]`);
      if (entryElement) {
        updateEntryContent(entryElement, tf.originalRank, tf.averageScore, tf.assayCount);
        entryElement.style.order = displayIndex.toString();
        entryElement.style.display = 'block';
      }
    });
    
    // Show message if no rankings available
    const rankingList = document.getElementById('ranking-list');
    if (filteredRankings.length === 0 && rankingList) {
      // Create or update empty state message
      let emptyMessage = document.getElementById('empty-message');
      if (!emptyMessage) {
        emptyMessage = document.createElement('div');
        emptyMessage.id = 'empty-message';
        emptyMessage.className = 'px-6 py-8 text-center text-gray-500';
        rankingList.appendChild(emptyMessage);
      }
      
      // Update message based on whether it's a search filter or assay filter
      if (searchTerm && rankings.length > 0) {
        emptyMessage.textContent = `No transcription factors found matching "${searchTerm}".`;
      } else if (searchTerm) {
        emptyMessage.textContent = `No transcription factors found for selected assays matching "${searchTerm}".`;
      } else {
        emptyMessage.textContent = 'No transcription factors found for selected assays.';
      }
      
      emptyMessage.style.display = 'block';
    } else {
      // Hide empty message if it exists
      const emptyMessage = document.getElementById('empty-message');
      if (emptyMessage) {
        emptyMessage.style.display = 'none';
      }
    }
  }
  
  // Update rankings when assay selection changes
  function observeAssayChanges() {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'attributes' && mutation.attributeName === 'data-active') {
          updateRankingDisplay();
        }
      });
    });
    
    // Observe all assay toggle buttons
    document.querySelectorAll('.assay-toggle').forEach(button => {
      observer.observe(button, { attributes: true });
    });
  }
  
  function setupSearchFunctionality() {
    const searchInput = document.getElementById('tf-search');
    const clearButton = document.getElementById('clear-search');
    
    if (searchInput) {
      // Update search results as user types
      searchInput.addEventListener('input', (e) => {
        const value = e.target.value;
        
        // Show/hide clear button
        if (clearButton) {
          clearButton.style.display = value ? 'flex' : 'none';
        }
        
        // Update rankings display
        updateRankingDisplay();
      });
      
      // Handle Enter key
      searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          updateRankingDisplay();
        }
      });
    }
    
    if (clearButton) {
      clearButton.addEventListener('click', () => {
        if (searchInput) {
          searchInput.value = '';
          clearButton.style.display = 'none';
          updateRankingDisplay();
          searchInput.focus();
        }
      });
    }
  }

  function initializeComponent() {
    updateRankingDisplay();
    observeAssayChanges();
    setupSearchFunctionality();
  }

  // Initialize rankings on page load
  document.addEventListener('DOMContentLoaded', initializeComponent);
  
  // Also update immediately if DOM is already loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeComponent);
  } else {
    initializeComponent();
  }
</script> 