---
import "../../../styles/global.css";
import LoadingAnimation from "../../../components/LoadingAnimation.astro";
import candidateRegions from "../../../assets/candidate_regions.json";
import geneLocations from "../../../assets/gene_locations.json";
import params from "../../../assets/params.json";
import { gzipSync } from 'node:zlib';

export async function getStaticPaths() {
  // Import all TF JSON files using glob pattern
  const tfJsonFiles = import.meta.glob('../../../assets/transcription_factors/*.json', { 
    eager: true, 
    query: '?raw',
    import: 'default'
  });

  const paths: any[] = [];

  // For each TF, extract target genes and create paths
  for (const [path, content] of Object.entries(tfJsonFiles)) {
    const fileName = path.split('/').pop()?.replace('.json', '');
    if (!fileName) continue;

    try {
      const tfData = JSON.parse(content as string);
      const targetGenesData = tfData.target_genes || {};
      
      // Collect all unique target genes across all assays
      const allTargetGenes = new Set();
      Object.values(targetGenesData).forEach((assayData: any) => {
        if (assayData && typeof assayData === 'object') {
          Object.keys(assayData).forEach(gene => allTargetGenes.add(gene));
        }
      });

      // Create a path for each TF-target gene combination
      allTargetGenes.forEach(targetGene => {
        paths.push({
          params: { 
            tf: fileName.toLowerCase(), 
            target: (targetGene as string).toLowerCase() 
          },
          props: { 
            tfName: fileName, 
            targetGene: targetGene as string,
            tfData: tfData
          }
        });
      });
    } catch (error) {
      console.error(`Error parsing JSON for ${fileName}:`, error);
    }
  }
  
  return paths;
}

interface Props {
  tfName: string;
  targetGene: string;
  tfData: any;
}

const { tfName, targetGene, tfData }: Props = Astro.props;

// Derive TF gene symbol (strip potential motif/version in parentheses)
const tfSymbol = tfName?.includes('(') ? tfName.split('(')[0] : tfName;

// Build a lowercase index for gene locations (case-insensitive lookup)
const geneLocationsLower: Record<string, any> = Object.fromEntries(
  Object.entries(geneLocations as any).map(([k, v]) => [k.toLowerCase(), v])
);

// Determine genome from params.json; if missing, disable binding sites tab
const genomeFromParams: string | undefined = (params as any)["Reference genome options"]?.genome;
const bindingSitesEnabled: boolean = !!genomeFromParams;
const genomeParam: string | undefined = bindingSitesEnabled ? genomeFromParams : undefined;

// Compression utility function
function compressBedText(text: string): string {
  try {
    const compressed = gzipSync(Buffer.from(text, 'utf8'));
    return compressed.toString('base64');
  } catch (e) {
    console.warn('Failed to compress BED text, using original:', e);
    return text;
  }
}

// Function to check if a genomic region is within 1Mb of the target gene
function isWithinTargetGeneRegion(chrom: string, start: number, end: number, targetGene: string): boolean {
  const geneInfo = (geneLocations as any)[targetGene] || geneLocationsLower[targetGene?.toLowerCase?.()] || undefined;
  if (!geneInfo) {
    // If gene location not found, include all regions (fallback behavior)
    return true;
  }
  
  // Check if chromosomes match
  if (chrom !== geneInfo.chrom) {
    return false;
  }
  
  // Define 100Mb window around the gene
  const windowSize = 100000000; // 100 megabases
  const geneStart = geneInfo.start;
  const geneEnd = geneInfo.end;
  const windowStart = Math.max(0, geneStart - windowSize);
  const windowEnd = geneEnd + windowSize;
  
  // Check if region overlaps with the window
  return !(end < windowStart || start > windowEnd);
}

// Build BED tracks (per condition) server-side with per-assay colors via itemRgb
// If fimoData is missing, still create empty per-condition tracks inferred from tfData.tg_affinities
function buildServerBedTracks(fimoData: any, tfDataLocal: any, tfSymbolLocal: string, targetGeneLocal: string): Array<{ name: string; format: 'bed'; compressedText: string }> {
  const tracks: Array<{ name: string; format: 'bed'; compressedText: string }> = [];
  // simple color palette
  const palette = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#a65628', '#f781bf', '#999999', '#66c2a5', '#8da0cb'];
  function hexToRgb(hex: string): string {
    const m = hex.replace('#', '');
    const r = parseInt(m.slice(0, 2), 16);
    const g = parseInt(m.slice(2, 4), 16);
    const b = parseInt(m.slice(4, 6), 16);
    return `${r},${g},${b}`;
  }
  function assayToRgb(assay: string): string {
    let hash = 0;
    for (let i = 0; i < assay.length; i++) {
      hash = ((hash << 5) - hash) + assay.charCodeAt(i);
      hash |= 0;
    }
    const idx = Math.abs(hash) % palette.length;
    return hexToRgb(palette[idx]);
  }
  try {
    let conditionKeys = fimoData ? Object.keys(fimoData || {}) : Object.keys((tfDataLocal?.tg_affinities) || {});
    
    if (!conditionKeys || conditionKeys.length === 0) {
      // Fallback: infer conditions from candidate regions
      conditionKeys = Object.keys((candidateRegions as any) || {});
      
    }
    conditionKeys.forEach((condition) => {
      const assays = fimoData ? ((fimoData as any)[condition] || {}) : {};
      let featureCount = 0;
      const lines: string[] = [];
      lines.push(`# BED (server) for ${tfSymbolLocal} | condition=${condition} | assays=ALL`);
      lines.push(`track name="${tfSymbolLocal} binding sites: ${condition}" itemRgb="On"`);
      // BED header is comment lines; real entries below
      Object.keys(assays).forEach((assay) => {
        const hits = (assays as any)[assay] || [];
        const rgb = assayToRgb(assay);
        (hits as any[]).forEach((hit) => {
          const chrom = hit.sequence_name;
          const start1 = typeof hit.start === 'number' ? hit.start : parseInt(hit.start, 10);
          const stop1 = typeof hit.stop === 'number' ? hit.stop : parseInt(hit.stop, 10);
          if (!chrom || isNaN(start1) || isNaN(stop1)) return;
          
          // BED is 0-based start, half-open end
          const chromStart = Math.max(0, start1 - 1);
          const chromEnd = stop1;
          
          // Filter: only include regions within 1Mb of target gene
          if (!isWithinTargetGeneRegion(chrom, chromStart, chromEnd, targetGeneLocal)) {
            return;
          }
          
          // Avoid spaces in name to keep BED columns intact
          const name = `${tfSymbolLocal}|${assay}`;
          const rawScore = typeof hit.score === 'number' ? hit.score : 0;
          const score = Math.max(0, Math.min(1000, Math.round(rawScore * 50)));
          const strand = hit.strand === '+' || hit.strand === '-' ? hit.strand : '.';
          const thickStart = chromStart;
          const thickEnd = chromEnd;
          const itemRgb = rgb; // R,G,B
          // BED9
          lines.push([chrom, chromStart, chromEnd, name, score, strand, thickStart, thickEnd, itemRgb].join('\t'));
          featureCount += 1;
        });
      });
      const trackName = featureCount > 0 
        ? `${tfSymbolLocal} binding sites: ${condition}`
        : `${tfSymbolLocal} binding sites: ${condition} (none)`;
      const bedText = lines.join('\n') + '\n';
      tracks.push({
        name: trackName,
        format: 'bed',
        compressedText: compressBedText(bedText)
      });
    });
  } catch (e) {}
  return tracks;
}

const fimoData = tfData && tfData.fimo_binding_sites ? tfData.fimo_binding_sites : undefined;
const serverBedTracks = buildServerBedTracks(fimoData, tfData, tfSymbol, targetGene);

// Build BED tracks from candidate regions (per condition, color by assay, name by sample)
function buildServerBedCandidateTracks(data: any, targetGeneLocal: string): Array<{ name: string; format: 'bed'; compressedText: string }> {
  const tracks: Array<{ name: string; format: 'bed'; compressedText: string }> = [];
  // Darker, high-contrast palette for region coloring
  const palette = ['#264653', '#1d3557', '#6a040f', '#3a0ca3', '#283618', '#5e548e', '#343a40', '#7f4f24', '#1b4332', '#2c3e50'];
  function hexToRgb(hex: string): string {
    const m = hex.replace('#', '');
    const r = parseInt(m.slice(0, 2), 16);
    const g = parseInt(m.slice(2, 4), 16);
    const b = parseInt(m.slice(4, 6), 16);
    return `${r},${g},${b}`;
  }
  function assayToRgb(assay: string): string {
    let hash = 0;
    for (let i = 0; i < assay.length; i++) {
      hash = ((hash << 5) - hash) + assay.charCodeAt(i);
      hash |= 0;
    }
    const idx = Math.abs(hash) % palette.length;
    return hexToRgb(palette[idx]);
  }
  try {
    Object.keys(data || {}).forEach((condition) => {
      const assays = (data as any)[condition] || {};
      let featureCount = 0;
      const lines: string[] = [];
      lines.push(`# BED (server) candidate regions | condition=${condition}`);
      lines.push(`track name="Candidate regions: ${condition}" itemRgb="On"`);
      Object.keys(assays).forEach((assay) => {
        const samples = (assays as any)[assay] || {};
        const rgb = assayToRgb(assay);
        Object.keys(samples || {}).forEach((sample) => {
          const chromMap = (samples as any)[sample] || {};
          Object.keys(chromMap || {}).forEach((chrom) => {
            const intervals = (chromMap as any)[chrom] || [];
            (intervals as any[]).forEach((pair) => {
              const start1 = Array.isArray(pair) && pair.length > 0 ? pair[0] : undefined;
              const stop1 = Array.isArray(pair) && pair.length > 1 ? pair[1] : undefined;
              if (!chrom || typeof start1 !== 'number' || typeof stop1 !== 'number') return;
              const chromStart = Math.max(0, start1); // source appears 0-based already; do not subtract 1
              const chromEnd = stop1;
              
              // Filter: only include regions within 1Mb of target gene
              if (!isWithinTargetGeneRegion(chrom, chromStart, chromEnd, targetGeneLocal)) {
                return;
              }
              
              // Avoid spaces in name to keep BED columns intact
              const name = `${assay}:${String(sample)}`;
              const score = 0;
              const strand = '.';
              const thickStart = chromStart;
              const thickEnd = chromEnd;
              const itemRgb = rgb;
              lines.push([chrom, chromStart, chromEnd, name, score, strand, thickStart, thickEnd, itemRgb].join('\t'));
              featureCount += 1;
            });
          });
        });
      });
      const trackName = featureCount > 0 
        ? `Candidate regions: ${condition}`
        : `Candidate regions: ${condition} (none)`;
      const bedText = lines.join('\n') + '\n';
      tracks.push({ name: trackName, format: 'bed', compressedText: compressBedText(bedText) });
    });
  } catch (e) {}
  return tracks;
}

const serverBedCandidateTracks = buildServerBedCandidateTracks(candidateRegions, targetGene);

// Calculate interaction data for this specific TF-target gene pair
let interactionData = {
  targetGeneScores: {} as Record<string, number>,
  affinityData: [] as Array<Record<string, any>>,
  affinityRatioData: [] as Array<Record<string, any>>,
  affinitySumData: [] as Array<Record<string, any>>,
  avgScore: 0,
  assayCount: 0,
  rank: 0
};

if (tfData) {
  // Extract target gene scores across all assays
  const targetGenesData = tfData.target_genes || {};
  Object.keys(targetGenesData).forEach(assay => {
    const score = targetGenesData[assay][targetGene];
    if (score !== undefined) {
      interactionData.targetGeneScores[assay] = score;
    }
  });

  // Calculate average score and assay count
  const scores = Object.values(interactionData.targetGeneScores) as number[];
  interactionData.avgScore = scores.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : 0;
  interactionData.assayCount = scores.length;

  // Calculate rank by comparing with all other target genes
  const allGeneScores: Record<string, number[]> = {};
  Object.keys(targetGenesData).forEach(assay => {
    Object.entries(targetGenesData[assay] || {}).forEach(([gene, score]) => {
      if (!allGeneScores[gene]) {
        allGeneScores[gene] = [];
      }
      allGeneScores[gene].push(score as number);
    });
  });

  // Calculate average scores for ranking
  const geneAvgScores = Object.entries(allGeneScores).map(([gene, scores]: [string, any]) => ({
    gene,
    avgScore: (scores as number[]).reduce((a, b) => a + b, 0) / (scores as number[]).length
  })).sort((a, b) => b.avgScore - a.avgScore);

  interactionData.rank = geneAvgScores.findIndex(item => item.gene === targetGene) + 1;

  // Extract affinity matrices
  const affinityData = tfData.tg_affinities || {};
  const conditions = Object.keys(affinityData);
  const allAssaysInAffinities = new Set();
  
  conditions.forEach(condition => {
    Object.keys(affinityData[condition] || {}).forEach(assay => {
      allAssaysInAffinities.add(assay);
    });
  });
  
  const assaysInAffinities = Array.from(allAssaysInAffinities);
  
  // Build affinity matrix for this target gene
  assaysInAffinities.forEach((assay: string) => {
    const row: Record<string, any> = { assay };
    conditions.forEach(condition => {
      const value = affinityData[condition]?.[assay]?.[targetGene];
      row[condition] = value !== undefined ? value : null;
    });
    interactionData.affinityData.push(row);
  });

  // Extract affinity ratio data
  const affinityRatioData = tfData.affinity_ratio || {};
  const ratioPairings = Object.keys(affinityRatioData);
  const allAssaysInRatios = new Set();
  
  ratioPairings.forEach(pairing => {
    Object.keys(affinityRatioData[pairing] || {}).forEach(assay => {
      allAssaysInRatios.add(assay);
    });
  });
  
  const assaysInRatios = Array.from(allAssaysInRatios);
  
  assaysInRatios.forEach((assay: string) => {
    const row: Record<string, any> = { assay };
    ratioPairings.forEach(pairing => {
      const value = affinityRatioData[pairing]?.[assay]?.[targetGene];
      row[pairing] = value !== undefined ? value : null;
    });
    interactionData.affinityRatioData.push(row);
  });

  // Extract affinity sum data
  const affinitySumData = tfData.affinity_sum || {};
  const sumPairings = Object.keys(affinitySumData);
  const allAssaysInSums = new Set();
  
  sumPairings.forEach(pairing => {
    Object.keys(affinitySumData[pairing] || {}).forEach(assay => {
      allAssaysInSums.add(assay);
    });
  });
  
  const assaysInSums = Array.from(allAssaysInSums);
  
  assaysInSums.forEach((assay: string) => {
    const row: Record<string, any> = { assay };
    sumPairings.forEach(pairing => {
      const value = affinitySumData[pairing]?.[assay]?.[targetGene];
      row[pairing] = value !== undefined ? value : null;
    });
    interactionData.affinitySumData.push(row);
  });
}
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <link rel="stylesheet" href="https://unpkg.com/@visa-ge/visage@latest/styles.css">
    <title>{tfName} - {targetGene} Interaction - nf-core/tfactivity report</title>
  </head>
  <body class="bg-gray-50">
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1/dist/pako.min.js" onerror="console.log('Hello')"></script>
    <script src="https://unpkg.com/@visa-ge/visage@latest/visage.js" onerror="window.__visageLoadError=true"></script>
    <div class="max-w-6xl mx-auto py-8 px-4">
      <!-- Loading Animation -->
      <LoadingAnimation 
        title={`Loading ${tfName}-${targetGene} Interaction Details`}
        subtitle="Processing transcription factor-target gene interaction data..."
        containerId="interaction-loading-overlay"
      />

      <!-- Main Content (initially hidden) -->
      <div id="interaction-main-content" style="display: none;">
        <!-- Header -->
        <div class="bg-white rounded-lg shadow-sm p-6 mb-6">
          <div class="flex items-center justify-between">
            <div>
              <h1 class="text-3xl font-bold text-gray-800">{tfName} → {targetGene}</h1>
              <p class="text-gray-600 mt-2">Transcription Factor - Target Gene Interaction Analysis</p>
            </div>
            <div class="text-right">
              <div class="text-2xl font-bold text-blue-600">{interactionData.avgScore.toFixed(3)}</div>
              <div class="text-sm text-gray-500">Average Score</div>
              <div class="text-sm text-gray-500">Rank #{interactionData.rank}</div>
            </div>
          </div>
          
          <!-- Navigation -->
          <div class="mt-6 pt-4 border-t border-gray-200">
            <a 
              href={`/tf/${tfName.toLowerCase()}/index.html`}
              class="inline-flex items-center text-blue-600 hover:text-blue-800 transition-colors duration-150"
            >
              <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
              </svg>
              Back to {tfName} Details
            </a>
            <a 
              href="/index.html" 
              class="inline-flex items-center ml-6 text-gray-600 hover:text-gray-800 transition-colors duration-150"
            >
              <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2H5a2 2 0 00-2 2z"></path>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V5a2 2 0 012-2h4a2 2 0 012 2v2"></path>
              </svg>
              Overview
            </a>
            <a 
              href={`https://www.genecards.org/cgi-bin/carddisp.pl?gene=${targetGene}`}
              target="_blank"
              rel="noopener noreferrer"
              class="inline-flex items-center ml-6 text-gray-600 hover:text-gray-800 transition-colors duration-150"
            >
              <img src="/genecards.ico" alt="GeneCards" class="w-4 h-4 mr-2" />
              View {targetGene} on GeneCards
            </a>
          </div>
        </div>

        <!-- Interaction Details Content -->
        <div class="bg-white rounded-lg shadow-sm p-6">
          <div class="space-y-6">
            <!-- Summary Stats -->
            <div class="grid grid-cols-3 gap-4">
              <div class="bg-blue-50 p-4 rounded-lg text-center">
                <div class="text-2xl font-bold text-blue-600">{interactionData.avgScore.toFixed(3)}</div>
                <div class="text-sm text-blue-800">Average Score</div>
              </div>
              <div class="bg-green-50 p-4 rounded-lg text-center">
                <div class="text-2xl font-bold text-green-600">#{interactionData.rank}</div>
                <div class="text-sm text-green-800">Rank</div>
              </div>
              <div class="bg-purple-50 p-4 rounded-lg text-center">
                <div class="text-2xl font-bold text-purple-600">{interactionData.assayCount}</div>
                <div class="text-sm text-purple-800">Assays</div>
              </div>
            </div>

            <!-- Scores by Assay -->
            <div>
              <h3 class="text-lg font-semibold text-gray-800 mb-4">Interaction Scores by Assay</h3>
              <div class="bg-gray-50 border border-gray-200 rounded-lg overflow-hidden">
                <div class="divide-y divide-gray-200">
                  {Object.entries(interactionData.targetGeneScores).map(([assay, score]) => (
                    <div class="px-4 py-3 flex items-center justify-between">
                      <span class="font-medium text-gray-900">{assay.replace('_', ' ')}</span>
                      <span class="font-medium text-blue-600">{(score as number).toFixed(3)}</span>
                    </div>
                  ))}
                </div>
              </div>
            </div>

            <!-- Tab Navigation -->
            <div class="mb-6">
              <nav class="flex justify-center space-x-8" aria-label="Tabs">
                <button id="tab-affinities" class="tab-button active whitespace-nowrap py-2 px-1 border-b-2 border-blue-500 font-medium text-sm text-blue-600">
                  Affinities
                </button>
                <button 
                  id="tab-binding-sites" 
                  class={`tab-button whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm ${bindingSitesEnabled ? 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300' : 'border-transparent text-gray-400 cursor-not-allowed opacity-60'}`}
                  disabled={!bindingSitesEnabled ? true : undefined}
                  title={!bindingSitesEnabled ? `nf-core/tfactivity was executed without the "genome" parameter. Thus, we cannot set up the genome browser view for the binding sites. Please re-run nf-core/tfactivity with the "genome" parameter enabled.` : undefined}
                  aria-disabled={!bindingSitesEnabled}
                >
                  Binding sites
                </button>
              </nav>
            </div>

            <!-- Tab Content -->
            <div id="content-affinities" class="tab-content active">
              <!-- Affinity Matrices -->
              <div class="space-y-6">
                <!-- Target Gene Affinities Heatmap -->
                <div id="affinity-heatmap"></div>

                <!-- Target Gene Affinity Ratios Heatmap -->
                <div id="affinity-ratio-heatmap"></div>

                <!-- Target Gene Affinity Sums Heatmap -->
                <div id="affinity-sum-heatmap"></div>
              </div>
            </div>

            <div id="content-binding-sites" class="tab-content hidden">
              {bindingSitesEnabled ? (
                <div>
                  <div id="visage-warning" class="mb-4 hidden bg-yellow-50 border border-yellow-200 text-yellow-800 rounded p-3">
                    Visualizing the binding sites in their genomic context requires an active internet connection. The internet connection is only needed for loading external data into the report. Your data is not uploaded in any way.
                  </div>
                  <visa-ge id="visage-browser" genome-id={genomeParam} selected-genes={`${tfSymbol},${targetGene}`} location={targetGene}></visa-ge>
                </div>
              ) : (
                <div class="text-center text-gray-500 py-6 bg-gray-50 border border-gray-200 rounded-lg">
                  nf-core/tfactivity was executed without the "genome" parameter. Thus, we cannot set up the genome browser view for the binding sites. Please re-run nf-core/tfactivity with the "genome" parameter enabled.
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Loading state management, heatmap rendering, and track loading script -->
    <script type="module" define:vars={{ tfName, targetGene, interactionData, serverBedTracks, serverBedCandidateTracks }}>

      // Decompress BED text that was compressed server-side (base64 gzipped)
      function decompressBedText(compressedText) {
        try {
          const binaryString = atob(compressedText);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          const decompressed = (window.pako && window.pako.inflate) ? window.pako.inflate(bytes, { to: 'string' }) : bytes;
          if (typeof decompressed === 'string') return decompressed;
          return new TextDecoder().decode(decompressed);
        } catch (e) {
          console.warn('Failed to decompress BED text, using original:', e);
          return compressedText;
        }
      }

      // Load BED tracks into the VISAGE genome browser component
      function loadBedTracksIntoVisage(serverBedTracks, serverBedCandidateTracks) {
        try {
          const browserEl = document.getElementById('visage-browser');
          if (browserEl) {
            const decompressedTracksA = Array.isArray(serverBedTracks)
              ? serverBedTracks.map(t => ({
                  name: t.name,
                  text: decompressBedText(t.compressedText),
                  format: t.format
                }))
              : [];

            const decompressedTracksB = Array.isArray(serverBedCandidateTracks)
              ? serverBedCandidateTracks.map(t => ({
                  name: t.name,
                  text: decompressBedText(t.compressedText),
                  format: t.format
                }))
              : [];

            const blobsA = decompressedTracksA.map(t => ({
              name: t.name,
              url: URL.createObjectURL(new Blob([t.text], { type: 'text/plain' })),
              format: t.format
            }));
            const blobsB = decompressedTracksB.map(t => ({
              name: t.name,
              url: URL.createObjectURL(new Blob([t.text], { type: 'text/plain' })),
              format: t.format
            }));

            const blobs = [...blobsA, ...blobsB];
            const tracks = blobs.map(b => ({ name: b.name, type: 'annotation', format: b.format, url: b.url }));
            browserEl.setAttribute('tracks', JSON.stringify(tracks));
            window.addEventListener('beforeunload', () => {
              blobs.forEach(b => URL.revokeObjectURL(b.url));
            });
          }
        } catch (e) {
          // Swallow errors
        }
      }

      // Expose for later invocation in this module
      window.loadBedTracksIntoVisage = loadBedTracksIntoVisage;

      // Utility function to render heatmaps
      function renderHeatmap(containerId, title, data, columns, colorScheme) {
        const container = document.getElementById(containerId);
        if (!container || !data || data.length === 0 || !columns || columns.length === 0) {
          if (container) {
            container.innerHTML = `
              <div>
                <h4 class="text-lg font-semibold text-gray-800 mb-4">${title}</h4>
                <div class="text-center text-gray-500 py-6 bg-gray-50 border border-gray-200 rounded-lg">No data available for this interaction</div>
              </div>
            `;
          }
          return;
        }

        // Find min and max values for color scaling
        let minValue = Infinity;
        let maxValue = -Infinity;
        
        data.forEach(row => {
          columns.forEach(column => {
            const value = row[column];
            if (value !== null && value !== undefined && !isNaN(value)) {
              minValue = Math.min(minValue, value);
              maxValue = Math.max(maxValue, value);
            }
          });
        });

        if (minValue === Infinity || maxValue === -Infinity) {
          container.innerHTML = `
            <div>
              <h4 class="text-lg font-semibold text-gray-800 mb-4">${title}</h4>
              <div class="text-center text-gray-500 py-6 bg-gray-50 border border-gray-200 rounded-lg">No valid data available for this interaction</div>
            </div>
          `;
          return;
        }

        // Create color function based on color scheme
        function getColor(value, normalizedValue) {
          const intensity = Math.round(255 - (normalizedValue * 155)); // 255 to 100
          
          switch (colorScheme.baseColor) {
            case 'blue':
              return `rgb(${intensity}, ${intensity}, 255)`;
            case 'green':
              return `rgb(${intensity}, 255, ${intensity})`;
            case 'red':
              return `rgb(255, ${intensity}, ${intensity})`;
            default:
              return `rgb(${intensity}, ${intensity}, 255)`;
          }
        }

        let heatmapHtml = `
          <div>
            <h4 class="text-lg font-semibold text-gray-800 mb-4">${title}</h4>
            <div class="bg-white border border-gray-200 rounded-lg overflow-hidden">
              <div class="overflow-x-auto">
                <table class="min-w-full border-collapse text-sm">
                  <thead>
                    <tr>
                      <th class="border border-gray-300 px-3 py-2 bg-gray-50 font-medium text-gray-700 text-left">Assay</th>
                      ${columns.map(column => `
                        <th class="border border-gray-300 px-3 py-2 bg-gray-50 font-medium text-gray-700 text-center">${column}</th>
                      `).join('')}
                    </tr>
                  </thead>
                  <tbody>
                    ${data.map(row => `
                      <tr>
                        <td class="border border-gray-300 px-3 py-2 bg-gray-50 font-medium text-gray-700">${row.assay.replace('_', ' ')}</td>
                        ${columns.map(column => {
                          const value = row[column];
                          let cellContent = '';
                          let cellStyle = 'background-color: #f3f4f6;'; // Default gray for N/A
                          
                          if (value !== null && value !== undefined && !isNaN(value)) {
                            // Normalize value to 0-1 range for color mapping
                            const normalizedValue = (value - minValue) / (maxValue - minValue);
                            cellStyle = `background-color: ${getColor(value, normalizedValue)};`;
                            
                            // Format the value
                            cellContent = value < 0.001 ? value.toExponential(2) : value.toFixed(4);
                          } else {
                            cellContent = 'N/A';
                          }
                          
                          return `<td class="border border-gray-300 px-3 py-2 text-center" style="${cellStyle}">${cellContent}</td>`;
                        }).join('')}
                      </tr>
                    `).join('')}
                  </tbody>
                </table>
              </div>
            </div>
            <div class="mt-3 flex items-center justify-center space-x-6 text-sm text-gray-600">
              <div class="flex items-center space-x-2">
                <div class="w-4 h-4 border border-gray-300" style="background-color: ${colorScheme.lowColor};"></div>
                <span>Low (${minValue.toExponential(2)})</span>
              </div>
              <div class="flex items-center space-x-2">
                <div class="w-4 h-4 border border-gray-300" style="background-color: ${colorScheme.highColor};"></div>
                <span>High (${maxValue.toExponential(2)})</span>
              </div>
            </div>
          </div>
        `;
        
        container.innerHTML = heatmapHtml;
      }

      // Handle loading state and render heatmaps
      document.addEventListener('DOMContentLoaded', () => {
        
        // Helper to trigger a VISAGE redraw (prefer visibility-signal bump)
        let __visageVisibilityTick = 0;
        function triggerVisageRedraw() {
          const el = document.getElementById('visage-browser');
          if (!el) return;
          // Preferred: bump visibility-signal attribute so component can react
          try {
            __visageVisibilityTick += 1;
            el.setAttribute('visibility-signal', String(__visageVisibilityTick));
            return;
          } catch {}
          try {
            if (typeof (el).requestRedraw === 'function') {
              (el).requestRedraw();
              return;
            }
          } catch {}
          try {
            el.dispatchEvent(new CustomEvent('visage-redraw'));
          } catch {}
          // Attribute toggle fallback to signal change
          try {
            el.setAttribute('data-redraw', String(Date.now()));
          } catch {}
        }
        // Setup tab functionality
        const affinitiesTab = document.getElementById('tab-affinities');
        const bindingSitesTab = document.getElementById('tab-binding-sites');
        const affinitiesContent = document.getElementById('content-affinities');
        const bindingSitesContent = document.getElementById('content-binding-sites');

        const allTabs = [affinitiesTab, bindingSitesTab];
        const allContents = [affinitiesContent, bindingSitesContent];

        function switchTab(activeTab, activeContent) {
          // Reset all tabs to inactive state
          allTabs.forEach(tab => {
            if (tab) {
              tab.classList.remove('active', 'border-blue-500', 'text-blue-600');
              tab.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
            }
          });

          // Reset all content to hidden
          allContents.forEach(content => {
            if (content) {
              content.classList.add('hidden');
              content.classList.remove('active');
            }
          });

          // Activate selected tab
          if (activeTab) {
            activeTab.classList.add('active', 'border-blue-500', 'text-blue-600');
            activeTab.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
          }

          // Show selected content
          if (activeContent) {
            activeContent.classList.remove('hidden');
            activeContent.classList.add('active');
          }
        }

        if (affinitiesTab && affinitiesContent) {
          affinitiesTab.addEventListener('click', () => {
            switchTab(affinitiesTab, affinitiesContent);
          });
        }

        if (bindingSitesTab && bindingSitesContent) {
          bindingSitesTab.addEventListener('click', () => {
            switchTab(bindingSitesTab, bindingSitesContent);
            // Trigger VISAGE redraw after tab switch
            triggerVisageRedraw();
          });
        }

        const checkContentReady = () => {
          const loadingOverlay = document.getElementById('interaction-loading-overlay');
          const mainContent = document.getElementById('interaction-main-content');
          
          if (loadingOverlay && mainContent) {
            // Add a small delay to ensure smooth transition
            setTimeout(() => {
              // Hide loading animation
              loadingOverlay.style.transition = 'opacity 0.5s ease-out';
              loadingOverlay.style.opacity = '0';
              
              setTimeout(() => {
                loadingOverlay.style.display = 'none';
                
                // Show main content with fade in
                mainContent.style.display = 'block';
                mainContent.style.opacity = '0';
                mainContent.style.transition = 'opacity 0.5s ease-in';
                
                // Trigger the fade in
                setTimeout(() => {
                  mainContent.style.opacity = '1';
                }, 10);

                // Render heatmaps after content is visible
                setTimeout(() => {
                  // Extract columns from interaction data
                  const affinityColumns = interactionData.affinityData.length > 0 ? 
                    Object.keys(interactionData.affinityData[0]).filter(key => key !== 'assay') : [];
                  const ratioColumns = interactionData.affinityRatioData.length > 0 ? 
                    Object.keys(interactionData.affinityRatioData[0]).filter(key => key !== 'assay') : [];
                  const sumColumns = interactionData.affinitySumData.length > 0 ? 
                    Object.keys(interactionData.affinitySumData[0]).filter(key => key !== 'assay') : [];

                  // Render all three heatmaps
                  renderHeatmap(
                    'affinity-heatmap',
                    'Target Gene Affinities Across Conditions',
                    interactionData.affinityData,
                    affinityColumns,
                    { baseColor: 'blue', lowColor: 'rgb(255, 255, 255)', highColor: 'rgb(100, 100, 255)' }
                  );

                  renderHeatmap(
                    'affinity-ratio-heatmap',
                    'Target Gene Affinity Ratios',
                    interactionData.affinityRatioData,
                    ratioColumns,
                    { baseColor: 'green', lowColor: 'rgb(255, 255, 255)', highColor: 'rgb(100, 255, 100)' }
                  );

                  renderHeatmap(
                    'affinity-sum-heatmap',
                    'Target Gene Affinity Sums',
                    interactionData.affinitySumData,
                    sumColumns,
                    { baseColor: 'red', lowColor: 'rgb(255, 255, 255)', highColor: 'rgb(255, 100, 100)' }
                  );

                  // Build per-track BED blobs and load into VISAGE via tracks
                  if (window.loadBedTracksIntoVisage) {
                    window.loadBedTracksIntoVisage(serverBedTracks, serverBedCandidateTracks);
                  }

                }, 100);
              }, 500);
            }, 800);
          } else {
            // If not ready yet, check again
            setTimeout(checkContentReady, 100);
          }
        };
        
        // Start checking after DOM is loaded
        checkContentReady();

        // Detect VISAGE load issues and show a warning if needed
        try {
          const warnIfVisageMissing = () => {
            const warnEl = document.getElementById('visage-warning');
            const visageDefined = typeof customElements !== 'undefined' && customElements.get && customElements.get('visa-ge');
            const scriptErrored = (window.__visageLoadError === true);
            if (warnEl && (scriptErrored || !visageDefined)) {
              warnEl.classList.remove('hidden');
            }
          };
          // Run soon after main content shows, and again after tab switch
          setTimeout(warnIfVisageMissing, 1200);
          document.getElementById('tab-binding-sites')?.addEventListener('click', () => setTimeout(warnIfVisageMissing, 200));
        } catch {}
      });
    </script>
  </body>
</html>

<style>
  html {
    font-family: system-ui, sans-serif;
  }

  /* Tab styling */
  .tab-button {
    transition: all 0.2s ease-in-out;
  }

  .tab-content {
    transition: opacity 0.3s ease-in-out;
  }

  .tab-content.hidden {
    display: none;
  }

  .tab-content:not(.hidden) {
    display: block;
  }
</style>
